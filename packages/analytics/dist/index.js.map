{"version":3,"sources":["../src/logger.ts","../src/aggregation.ts","../src/cache.ts","../src/config.ts","../src/models.ts","../src/sanitizer.ts","../src/validation.ts"],"sourcesContent":["/**\n * Structured logging system with configurable log levels and JSON output format.\n * Integrates with GitHub Actions logging and supports analytics data collection.\n */\n\nimport type {AnalyticsConfig} from './models.js'\nimport {env} from 'node:process'\n\nimport * as core from '@actions/core'\n\n/**\n * Log level enumeration for filtering log output.\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error'\n\n/**\n * Structured log entry with consistent format.\n */\nexport interface LogEntry {\n  /** Log entry timestamp in ISO 8601 format */\n  readonly timestamp: string\n  /** Log level */\n  readonly level: LogLevel\n  /** Log message */\n  readonly message: string\n  /** Logger component/module name */\n  readonly component: string\n  /** Optional structured data associated with the log entry */\n  readonly data?: Record<string, unknown>\n  /** Optional error information */\n  readonly error?: {\n    readonly name: string\n    readonly message: string\n    readonly stack?: string\n  }\n  /** GitHub Actions workflow run ID for correlation */\n  readonly runId?: string\n  /** Repository context for multi-repo analytics */\n  readonly repository?: string\n}\n\n/**\n * Log level hierarchy for filtering (higher numbers = more severe).\n */\nconst LOG_LEVEL_HIERARCHY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n} as const\n\n/**\n * Configuration options for the analytics logger.\n */\nexport interface LoggerConfig {\n  /** Minimum log level to output */\n  readonly level: LogLevel\n  /** Whether to output JSON format for structured parsing */\n  readonly json: boolean\n  /** Whether to use GitHub Actions native logging */\n  readonly useActionsLogging: boolean\n  /** Component name for this logger instance */\n  readonly component: string\n  /** Whether to include stack traces in error logs */\n  readonly includeStackTrace: boolean\n  /** Maximum length for log messages (truncates if exceeded) */\n  readonly maxMessageLength: number\n}\n\n/**\n * Default logger configuration values.\n */\nexport const DEFAULT_LOGGER_CONFIG: LoggerConfig = {\n  level: 'info',\n  json: true,\n  useActionsLogging: true,\n  component: 'analytics',\n  includeStackTrace: false,\n  maxMessageLength: 1000,\n} as const\n\n/**\n * Analytics logger with structured output and GitHub Actions integration.\n */\nexport class AnalyticsLogger {\n  private readonly config: LoggerConfig\n  private readonly logBuffer: LogEntry[] = []\n\n  constructor(config: Partial<LoggerConfig> = {}) {\n    this.config = {...DEFAULT_LOGGER_CONFIG, ...config}\n  }\n\n  /**\n   * Create a logger from analytics configuration.\n   */\n  static fromAnalyticsConfig(analyticsConfig: AnalyticsConfig, component = 'analytics'): AnalyticsLogger {\n    return new AnalyticsLogger({\n      level: analyticsConfig.logLevel,\n      component,\n      json: true,\n      useActionsLogging: true,\n      includeStackTrace: analyticsConfig.logLevel === 'debug',\n    })\n  }\n\n  /**\n   * Log a debug message with optional structured data.\n   */\n  debug(message: string, data?: Record<string, unknown>): void {\n    this.log('debug', message, data)\n  }\n\n  /**\n   * Log an info message with optional structured data.\n   */\n  info(message: string, data?: Record<string, unknown>): void {\n    this.log('info', message, data)\n  }\n\n  /**\n   * Log a warning message with optional structured data.\n   */\n  warn(message: string, data?: Record<string, unknown>): void {\n    this.log('warn', message, data)\n  }\n\n  /**\n   * Log an error message with optional structured data and error object.\n   */\n  error(message: string, error?: Error, data?: Record<string, unknown>): void {\n    const errorData = error\n      ? {\n          name: error.name,\n          message: error.message,\n          stack: this.config.includeStackTrace ? error.stack : undefined,\n        }\n      : undefined\n\n    this.log('error', message, data, errorData)\n  }\n\n  /**\n   * Log a performance timing measurement.\n   */\n  timing(operation: string, duration: number, data?: Record<string, unknown>): void {\n    this.info(`${operation} completed`, {\n      operation,\n      duration,\n      unit: 'ms',\n      ...data,\n    })\n  }\n\n  /**\n   * Log start of an operation for timing purposes.\n   */\n  operationStart(operation: string, data?: Record<string, unknown>): void {\n    this.debug(`${operation} started`, {\n      operation,\n      event: 'start',\n      timestamp: new Date().toISOString(),\n      ...data,\n    })\n  }\n\n  /**\n   * Log completion of an operation with duration.\n   */\n  operationEnd(operation: string, startTime: number, success = true, data?: Record<string, unknown>): void {\n    const duration = Date.now() - startTime\n    const level = success ? 'info' : 'warn'\n    const message = `${operation} ${success ? 'completed' : 'failed'}`\n\n    this.log(level, message, {\n      operation,\n      event: 'end',\n      success,\n      duration,\n      unit: 'ms',\n      ...data,\n    })\n  }\n\n  /**\n   * Get all log entries from the buffer.\n   */\n  getLogEntries(): readonly LogEntry[] {\n    return [...this.logBuffer]\n  }\n\n  /**\n   * Clear the log buffer.\n   */\n  clearBuffer(): void {\n    this.logBuffer.length = 0\n  }\n\n  /**\n   * Get log entries filtered by level.\n   */\n  getLogEntriesByLevel(level: LogLevel): readonly LogEntry[] {\n    const minLevel = LOG_LEVEL_HIERARCHY[level]\n    return this.logBuffer.filter(entry => LOG_LEVEL_HIERARCHY[entry.level] >= minLevel)\n  }\n\n  /**\n   * Export log entries in JSON format for analytics storage.\n   */\n  exportAsJson(): string {\n    return JSON.stringify(this.logBuffer, null, 2)\n  }\n\n  /**\n   * Core logging method with consistent structure and filtering.\n   */\n  private log(\n    level: LogLevel,\n    message: string,\n    data?: Record<string, unknown>,\n    error?: {readonly name: string; readonly message: string; readonly stack?: string},\n  ): void {\n    // Filter based on configured log level\n    if (LOG_LEVEL_HIERARCHY[level] < LOG_LEVEL_HIERARCHY[this.config.level]) {\n      return\n    }\n\n    // Truncate message if it exceeds maximum length\n    const truncatedMessage =\n      message.length > this.config.maxMessageLength ? `${message.slice(0, this.config.maxMessageLength)}...` : message\n\n    // Create structured log entry\n    const logEntry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message: truncatedMessage,\n      component: this.config.component,\n      data: data ? this.sanitizeData(data) : undefined,\n      error,\n      runId: env.GITHUB_RUN_ID,\n      repository: env.GITHUB_REPOSITORY,\n    }\n\n    // Add to buffer for later retrieval\n    this.logBuffer.push(logEntry)\n\n    // Output to console/GitHub Actions\n    this.outputLog(logEntry)\n  }\n\n  /**\n   * Output log entry to console or GitHub Actions logging.\n   */\n  private outputLog(entry: LogEntry): void {\n    if (this.config.useActionsLogging) {\n      // Use GitHub Actions native logging functions\n      switch (entry.level) {\n        case 'debug':\n          core.debug(this.formatLogMessage(entry))\n          break\n        case 'info':\n          core.info(this.formatLogMessage(entry))\n          break\n        case 'warn':\n          core.warning(this.formatLogMessage(entry))\n          break\n        case 'error':\n          core.error(this.formatLogMessage(entry))\n          break\n      }\n    } else {\n      // Use console logging with appropriate methods (only warn/error allowed)\n      const formattedMessage = this.formatLogMessage(entry)\n      switch (entry.level) {\n        case 'debug':\n        case 'info':\n          // eslint-disable-next-line no-console\n          console.log(formattedMessage)\n          break\n        case 'warn':\n          console.warn(formattedMessage)\n          break\n        case 'error':\n          console.error(formattedMessage)\n          break\n      }\n    }\n  }\n\n  /**\n   * Format log entry for output based on configuration.\n   */\n  private formatLogMessage(entry: LogEntry): string {\n    if (this.config.json) {\n      return JSON.stringify(entry)\n    }\n\n    // Human-readable format for non-JSON output\n    let message = `[${entry.timestamp}] ${entry.level.toUpperCase()} [${entry.component}] ${entry.message}`\n\n    if (entry.data && Object.keys(entry.data).length > 0) {\n      message += ` ${JSON.stringify(entry.data)}`\n    }\n\n    if (entry.error) {\n      message += ` Error: ${entry.error.name}: ${entry.error.message}`\n      if (typeof entry.error?.stack === 'string' && entry.error.stack.length > 0) {\n        message += `\\n${entry.error.stack}`\n      }\n    }\n\n    return message\n  }\n\n  /**\n   * Sanitize data to prevent logging sensitive information.\n   * This is a basic implementation - full sanitization is in sanitizer.ts.\n   */\n  private sanitizeData(data: Record<string, unknown>): Record<string, unknown> {\n    const sensitiveKeys = ['token', 'password', 'secret', 'key', 'auth', 'credential']\n    const sanitized: Record<string, unknown> = {}\n\n    for (const [key, value] of Object.entries(data)) {\n      const lowerKey = key.toLowerCase()\n      if (sensitiveKeys.some(sensitiveKey => lowerKey.includes(sensitiveKey))) {\n        sanitized[key] = '[REDACTED]'\n      } else if (typeof value === 'object' && value !== null) {\n        sanitized[key] = Array.isArray(value) ? '[Array]' : '[Object]'\n      } else {\n        sanitized[key] = value\n      }\n    }\n\n    return sanitized\n  }\n}\n\n/**\n * Create a singleton logger instance for global use.\n */\nlet globalLogger: AnalyticsLogger | undefined\n\n/**\n * Get or create the global analytics logger instance.\n */\nexport function getLogger(config?: Partial<LoggerConfig>): AnalyticsLogger {\n  if (!globalLogger) {\n    globalLogger = new AnalyticsLogger(config)\n  }\n  return globalLogger\n}\n\n/**\n * Set the global analytics logger instance.\n */\nexport function setLogger(logger: AnalyticsLogger): void {\n  globalLogger = logger\n}\n\n/**\n * Reset the global logger (useful for testing).\n */\nexport function resetLogger(): void {\n  globalLogger = undefined\n}\n\n/**\n * Utility function to measure execution time of async operations.\n */\nexport async function withTiming<T>(\n  operation: string,\n  fn: () => Promise<T>,\n  logger?: AnalyticsLogger,\n): Promise<{result: T; duration: number}> {\n  const log = logger ?? getLogger()\n  const startTime = Date.now()\n\n  log.operationStart(operation)\n\n  try {\n    const result = await fn()\n    const duration = Date.now() - startTime\n    log.operationEnd(operation, startTime, true, {duration})\n    return {result, duration}\n  } catch (error) {\n    const duration = Date.now() - startTime\n    log.operationEnd(operation, startTime, false, {duration})\n    log.error(`${operation} failed`, error instanceof Error ? error : new Error(String(error)))\n    throw error\n  }\n}\n\n/**\n * Utility function to measure execution time of synchronous operations.\n */\nexport function withTimingSync<T>(\n  operation: string,\n  fn: () => T,\n  logger?: AnalyticsLogger,\n): {result: T; duration: number} {\n  const log = logger ?? getLogger()\n  const startTime = Date.now()\n\n  log.operationStart(operation)\n\n  try {\n    const result = fn()\n    const duration = Date.now() - startTime\n    log.operationEnd(operation, startTime, true, {duration})\n    return {result, duration}\n  } catch (error) {\n    const duration = Date.now() - startTime\n    log.operationEnd(operation, startTime, false, {duration})\n    log.error(`${operation} failed`, error instanceof Error ? error : new Error(String(error)))\n    throw error\n  }\n}\n","/**\n * Data aggregation utilities for multi-repository analytics reporting.\n * Provides functions to combine, summarize, and analyze analytics data across repositories.\n */\n\nimport type {AggregatedAnalytics, AnalyticsEvent, FailureCategory, RepositoryInfo, Timestamp} from './models.js'\n\nimport {AnalyticsLogger} from './logger.js'\n\n/**\n * Aggregation period for time-based analytics.\n */\nexport type AggregationPeriod = 'day' | 'week' | 'month' | 'year'\n\n/**\n * Aggregation options for customizing data processing.\n */\nexport interface AggregationOptions {\n  /** Time period for aggregation */\n  readonly period: AggregationPeriod\n  /** Start timestamp for aggregation (ISO 8601) */\n  readonly startTime?: Timestamp\n  /** End timestamp for aggregation (ISO 8601) */\n  readonly endTime?: Timestamp\n  /** Repository filter (if specified, only include these repositories) */\n  readonly repositories?: readonly string[]\n  /** Whether to include detailed breakdowns */\n  readonly includeBreakdowns: boolean\n  /** Minimum sample size for statistical calculations */\n  readonly minSampleSize: number\n  /** Whether to exclude outliers from calculations */\n  readonly excludeOutliers: boolean\n  /** Percentile threshold for outlier detection (0-100) */\n  readonly outlierThreshold: number\n}\n\n/**\n * Default aggregation options.\n */\nexport const DEFAULT_AGGREGATION_OPTIONS: AggregationOptions = {\n  period: 'day',\n  includeBreakdowns: true,\n  minSampleSize: 5,\n  excludeOutliers: true,\n  outlierThreshold: 95,\n} as const\n\n/**\n * Detailed breakdown statistics for metrics.\n */\nexport interface MetricBreakdown {\n  /** Total count of data points */\n  readonly count: number\n  /** Sum of all values */\n  readonly sum: number\n  /** Average value */\n  readonly average: number\n  /** Median value */\n  readonly median: number\n  /** Minimum value */\n  readonly min: number\n  /** Maximum value */\n  readonly max: number\n  /** Standard deviation */\n  readonly standardDeviation: number\n  /** 95th percentile */\n  readonly p95: number\n  /** 99th percentile */\n  readonly p99: number\n}\n\n/**\n * Extended aggregated analytics with detailed breakdowns.\n */\nexport interface ExtendedAggregatedAnalytics extends AggregatedAnalytics {\n  /** Cache metrics breakdown */\n  readonly cacheBreakdown: {\n    readonly hitRate: MetricBreakdown\n    readonly duration: MetricBreakdown\n    readonly size: MetricBreakdown\n  }\n  /** Docker metrics breakdown */\n  readonly dockerBreakdown: {\n    readonly duration: MetricBreakdown\n    readonly successRate: number\n  }\n  /** API metrics breakdown */\n  readonly apiBreakdown: {\n    readonly duration: MetricBreakdown\n    readonly successRate: number\n    readonly rateLimitHits: number\n  }\n  /** Repository statistics */\n  readonly repositoryStats: {\n    readonly totalRepositories: number\n    readonly activeRepositories: number\n    readonly repositoriesByLanguage: Record<string, number>\n    readonly repositoriesBySize: Record<string, number>\n  }\n}\n\n/**\n * Analytics aggregator for processing multiple events into summary statistics.\n */\nexport class AnalyticsAggregator {\n  private readonly logger: AnalyticsLogger\n\n  constructor(logger?: AnalyticsLogger) {\n    this.logger = logger ?? new AnalyticsLogger({component: 'aggregator'})\n  }\n\n  /**\n   * Aggregate multiple analytics events into summary statistics.\n   */\n  async aggregateEvents(\n    events: readonly AnalyticsEvent[],\n    options: Partial<AggregationOptions> = {},\n  ): Promise<AggregatedAnalytics> {\n    const opts = {...DEFAULT_AGGREGATION_OPTIONS, ...options}\n\n    this.logger.operationStart('aggregate-events', {\n      eventCount: events.length,\n      period: opts.period,\n    })\n\n    const startTime = Date.now()\n\n    try {\n      // Filter events by time period and repositories if specified\n      const filteredEvents = this.filterEventsByOptions(events, opts)\n\n      if (filteredEvents.length === 0) {\n        this.logger.warn('No events to aggregate after filtering', {options: opts})\n        return this.createEmptyAggregation(opts)\n      }\n\n      // Calculate aggregation period bounds\n      const {periodStart, periodEnd} = this.calculatePeriodBounds(filteredEvents, opts)\n\n      // Aggregate cache metrics\n      const cacheMetrics = this.aggregateCacheMetrics(filteredEvents)\n\n      // Aggregate Docker metrics\n      const dockerMetrics = this.aggregateDockerMetrics(filteredEvents)\n\n      // Aggregate API metrics\n      const apiMetrics = this.aggregateApiMetrics(filteredEvents)\n\n      // Aggregate failure metrics\n      const failuresByCategory = this.aggregateFailureMetrics(filteredEvents)\n\n      // Aggregate action metrics\n      const actionMetrics = this.aggregateActionMetrics(filteredEvents)\n\n      // Count unique repositories\n      const repositoryCount = new Set(filteredEvents.map(event => event.repository.fullName)).size\n\n      const aggregated: AggregatedAnalytics = {\n        periodStart,\n        periodEnd,\n        eventCount: filteredEvents.length,\n        repositoryCount,\n        cacheHitRate: cacheMetrics.hitRate,\n        avgCacheDuration: cacheMetrics.avgDuration,\n        avgDockerDuration: dockerMetrics.avgDuration,\n        avgApiDuration: apiMetrics.avgDuration,\n        failuresByCategory,\n        avgActionDuration: actionMetrics.avgDuration,\n        actionSuccessRate: actionMetrics.successRate,\n        schemaVersion: '1.0.0',\n      }\n\n      this.logger.operationEnd('aggregate-events', startTime, true, {\n        resultEventCount: aggregated.eventCount,\n        repositories: aggregated.repositoryCount,\n      })\n\n      return aggregated\n    } catch (error) {\n      this.logger.operationEnd('aggregate-events', startTime, false)\n      this.logger.error('Failed to aggregate events', error instanceof Error ? error : new Error(String(error)))\n      throw error\n    }\n  }\n\n  /**\n   * Aggregate events with detailed breakdowns and extended statistics.\n   */\n  async aggregateEventsExtended(\n    events: readonly AnalyticsEvent[],\n    options: Partial<AggregationOptions> = {},\n  ): Promise<ExtendedAggregatedAnalytics> {\n    const baseAggregation = await this.aggregateEvents(events, options)\n    const opts = {...DEFAULT_AGGREGATION_OPTIONS, ...options}\n\n    const filteredEvents = this.filterEventsByOptions(events, opts)\n\n    // Calculate detailed breakdowns\n    const cacheBreakdown = this.calculateCacheBreakdown(filteredEvents)\n    const dockerBreakdown = this.calculateDockerBreakdown(filteredEvents)\n    const apiBreakdown = this.calculateApiBreakdown(filteredEvents)\n    const repositoryStats = this.calculateRepositoryStats(filteredEvents)\n\n    return {\n      ...baseAggregation,\n      cacheBreakdown,\n      dockerBreakdown,\n      apiBreakdown,\n      repositoryStats,\n    }\n  }\n\n  /**\n   * Filter events based on aggregation options.\n   */\n  private filterEventsByOptions(\n    events: readonly AnalyticsEvent[],\n    options: AggregationOptions,\n  ): readonly AnalyticsEvent[] {\n    return events.filter(event => {\n      // Filter by time range if specified\n      if (typeof options.startTime === 'string' && options.startTime.length > 0) {\n        return event.timestamp >= options.startTime\n      }\n      if (typeof options.endTime === 'string' && options.endTime.length > 0) {\n        return event.timestamp <= options.endTime\n      }\n\n      // Filter by repositories if specified\n      if (options.repositories && options.repositories.length > 0) {\n        return options.repositories.includes(event.repository.fullName)\n      }\n\n      return true\n    })\n  }\n\n  /**\n   * Calculate period bounds for aggregation.\n   */\n  private calculatePeriodBounds(\n    events: readonly AnalyticsEvent[],\n    options: AggregationOptions,\n  ): {periodStart: Timestamp; periodEnd: Timestamp} {\n    if (\n      typeof options.startTime === 'string' &&\n      options.startTime.length > 0 &&\n      typeof options.endTime === 'string' &&\n      options.endTime.length > 0\n    ) {\n      return {periodStart: options.startTime, periodEnd: options.endTime}\n    }\n\n    const timestamps = events.map(event => new Date(event.timestamp).getTime()).sort((a, b) => a - b)\n    const minTimestamp = timestamps[0] ?? Date.now()\n    const maxTimestamp = timestamps.at(-1) ?? Date.now()\n\n    return {\n      periodStart: new Date(minTimestamp).toISOString(),\n      periodEnd: new Date(maxTimestamp).toISOString(),\n    }\n  }\n\n  /**\n   * Aggregate cache metrics from events.\n   */\n  private aggregateCacheMetrics(events: readonly AnalyticsEvent[]): {\n    hitRate: number\n    avgDuration: number\n  } {\n    const cacheMetrics = events.flatMap(event => event.cache)\n    const restoreOperations = cacheMetrics.filter(metric => metric.operation === 'restore')\n\n    if (restoreOperations.length === 0) {\n      return {hitRate: 0, avgDuration: 0}\n    }\n\n    const hits = restoreOperations.filter(metric => metric.hit === true).length\n    const hitRate = (hits / restoreOperations.length) * 100\n\n    const totalDuration = cacheMetrics.reduce((sum, metric) => sum + metric.duration, 0)\n    const avgDuration = cacheMetrics.length > 0 ? totalDuration / cacheMetrics.length : 0\n\n    return {hitRate, avgDuration}\n  }\n\n  /**\n   * Aggregate Docker metrics from events.\n   */\n  private aggregateDockerMetrics(events: readonly AnalyticsEvent[]): {\n    avgDuration: number\n  } {\n    const dockerMetrics = events.flatMap(event => event.docker)\n\n    if (dockerMetrics.length === 0) {\n      return {avgDuration: 0}\n    }\n\n    const totalDuration = dockerMetrics.reduce((sum, metric) => sum + metric.duration, 0)\n    const avgDuration = totalDuration / dockerMetrics.length\n\n    return {avgDuration}\n  }\n\n  /**\n   * Aggregate API metrics from events.\n   */\n  private aggregateApiMetrics(events: readonly AnalyticsEvent[]): {\n    avgDuration: number\n  } {\n    const apiMetrics = events.flatMap(event => event.api)\n\n    if (apiMetrics.length === 0) {\n      return {avgDuration: 0}\n    }\n\n    const totalDuration = apiMetrics.reduce((sum, metric) => sum + metric.duration, 0)\n    const avgDuration = totalDuration / apiMetrics.length\n\n    return {avgDuration}\n  }\n\n  /**\n   * Aggregate failure metrics from events.\n   */\n  private aggregateFailureMetrics(events: readonly AnalyticsEvent[]): Record<FailureCategory, number> {\n    const failures = events.flatMap(event => event.failures)\n\n    const failuresByCategory: Record<FailureCategory, number> = {\n      permissions: 0,\n      authentication: 0,\n      'cache-corruption': 0,\n      'network-issues': 0,\n      'configuration-error': 0,\n      'docker-issues': 0,\n      'api-limits': 0,\n      timeout: 0,\n      unknown: 0,\n    }\n\n    for (const failure of failures) {\n      failuresByCategory[failure.category]++\n    }\n\n    return failuresByCategory\n  }\n\n  /**\n   * Aggregate action metrics from events.\n   */\n  private aggregateActionMetrics(events: readonly AnalyticsEvent[]): {\n    avgDuration: number\n    successRate: number\n  } {\n    if (events.length === 0) {\n      return {avgDuration: 0, successRate: 0}\n    }\n\n    const totalDuration = events.reduce((sum, event) => sum + event.action.duration, 0)\n    const avgDuration = totalDuration / events.length\n\n    const successfulActions = events.filter(event => event.action.success).length\n    const successRate = (successfulActions / events.length) * 100\n\n    return {avgDuration, successRate}\n  }\n\n  /**\n   * Calculate detailed cache metrics breakdown.\n   */\n  private calculateCacheBreakdown(events: readonly AnalyticsEvent[]): {\n    readonly hitRate: MetricBreakdown\n    readonly duration: MetricBreakdown\n    readonly size: MetricBreakdown\n  } {\n    const cacheMetrics = events.flatMap(event => event.cache)\n    const restoreOperations = cacheMetrics.filter(metric => metric.operation === 'restore')\n\n    const hitRates = restoreOperations.map(metric => (metric.hit === true ? 100 : 0))\n    const durations = cacheMetrics.map(metric => metric.duration)\n    const sizes = cacheMetrics.map(metric => metric.size ?? 0)\n\n    return {\n      hitRate: this.calculateMetricBreakdown(hitRates),\n      duration: this.calculateMetricBreakdown(durations),\n      size: this.calculateMetricBreakdown(sizes),\n    }\n  }\n\n  /**\n   * Calculate detailed Docker metrics breakdown.\n   */\n  private calculateDockerBreakdown(events: readonly AnalyticsEvent[]): {\n    readonly duration: MetricBreakdown\n    readonly successRate: number\n  } {\n    const dockerMetrics = events.flatMap(event => event.docker)\n    const durations = dockerMetrics.map(metric => metric.duration)\n    const successful = dockerMetrics.filter(metric => metric.success).length\n    const successRate = dockerMetrics.length > 0 ? (successful / dockerMetrics.length) * 100 : 0\n\n    return {\n      duration: this.calculateMetricBreakdown(durations),\n      successRate,\n    }\n  }\n\n  /**\n   * Calculate detailed API metrics breakdown.\n   */\n  private calculateApiBreakdown(events: readonly AnalyticsEvent[]): {\n    readonly duration: MetricBreakdown\n    readonly successRate: number\n    readonly rateLimitHits: number\n  } {\n    const apiMetrics = events.flatMap(event => event.api)\n    const durations = apiMetrics.map(metric => metric.duration)\n    const successful = apiMetrics.filter(metric => metric.success).length\n    const successRate = apiMetrics.length > 0 ? (successful / apiMetrics.length) * 100 : 0\n    const rateLimitHits = apiMetrics.filter(metric => metric.secondaryRateLimit === true).length\n\n    return {\n      duration: this.calculateMetricBreakdown(durations),\n      successRate,\n      rateLimitHits,\n    }\n  }\n\n  /**\n   * Calculate repository statistics.\n   */\n  private calculateRepositoryStats(events: readonly AnalyticsEvent[]): {\n    readonly totalRepositories: number\n    readonly activeRepositories: number\n    readonly repositoriesByLanguage: Record<string, number>\n    readonly repositoriesBySize: Record<string, number>\n  } {\n    const repositories = new Map<string, RepositoryInfo>()\n\n    for (const event of events) {\n      repositories.set(event.repository.fullName, event.repository)\n    }\n\n    const totalRepositories = repositories.size\n    const activeRepositories = totalRepositories // All repositories in events are considered active\n\n    const repositoriesByLanguage: Record<string, number> = {}\n    const repositoriesBySize: Record<string, number> = {}\n\n    for (const repo of repositories.values()) {\n      // Count by language\n      const language = repo.language ?? 'unknown'\n      repositoriesByLanguage[language] = (repositoriesByLanguage[language] ?? 0) + 1\n\n      // Count by size category\n      const size = repo.size ?? 0\n      const sizeCategory = this.categorizeSizeCategory(size)\n      repositoriesBySize[sizeCategory] = (repositoriesBySize[sizeCategory] ?? 0) + 1\n    }\n\n    return {\n      totalRepositories,\n      activeRepositories,\n      repositoriesByLanguage,\n      repositoriesBySize,\n    }\n  }\n\n  /**\n   * Calculate detailed metric breakdown statistics.\n   */\n  private calculateMetricBreakdown(values: readonly number[]): MetricBreakdown {\n    if (values.length === 0) {\n      return {\n        count: 0,\n        sum: 0,\n        average: 0,\n        median: 0,\n        min: 0,\n        max: 0,\n        standardDeviation: 0,\n        p95: 0,\n        p99: 0,\n      }\n    }\n\n    const sortedValues = [...values].sort((a, b) => a - b)\n    const count = values.length\n    const sum = values.reduce((acc, val) => acc + val, 0)\n    const average = sum / count\n    const min = sortedValues[0] ?? 0\n    const max = sortedValues.at(-1) ?? 0\n\n    // Calculate median\n    const medianIndex = Math.floor(count / 2)\n    const median =\n      count % 2 === 0\n        ? ((sortedValues[medianIndex - 1] ?? 0) + (sortedValues[medianIndex] ?? 0)) / 2\n        : (sortedValues[medianIndex] ?? 0)\n\n    // Calculate standard deviation\n    const variance = values.reduce((acc, val) => acc + (val - average) ** 2, 0) / count\n    const standardDeviation = Math.sqrt(variance)\n\n    // Calculate percentiles\n    const p95Index = Math.floor(count * 0.95)\n    const p99Index = Math.floor(count * 0.99)\n    const p95 = sortedValues[Math.min(p95Index, count - 1)] ?? 0\n    const p99 = sortedValues[Math.min(p99Index, count - 1)] ?? 0\n\n    return {\n      count,\n      sum,\n      average,\n      median,\n      min,\n      max,\n      standardDeviation,\n      p95,\n      p99,\n    }\n  }\n\n  /**\n   * Categorize repository size for statistics.\n   */\n  private categorizeSizeCategory(size: number): string {\n    if (size < 1000) return 'small'\n    if (size < 10000) return 'medium'\n    if (size < 100000) return 'large'\n    return 'enterprise'\n  }\n\n  /**\n   * Create empty aggregation result.\n   */\n  private createEmptyAggregation(options: AggregationOptions): AggregatedAnalytics {\n    const now = new Date().toISOString()\n    return {\n      periodStart: options.startTime ?? now,\n      periodEnd: options.endTime ?? now,\n      eventCount: 0,\n      repositoryCount: 0,\n      cacheHitRate: 0,\n      avgCacheDuration: 0,\n      avgDockerDuration: 0,\n      avgApiDuration: 0,\n      failuresByCategory: {\n        permissions: 0,\n        authentication: 0,\n        'cache-corruption': 0,\n        'network-issues': 0,\n        'configuration-error': 0,\n        'docker-issues': 0,\n        'api-limits': 0,\n        timeout: 0,\n        unknown: 0,\n      },\n      avgActionDuration: 0,\n      actionSuccessRate: 0,\n      schemaVersion: '1.0.0',\n    }\n  }\n}\n\n/**\n * Utility function to merge multiple aggregated analytics into a single result.\n */\nexport function mergeAggregatedAnalytics(aggregations: readonly AggregatedAnalytics[]): AggregatedAnalytics {\n  if (aggregations.length === 0) {\n    throw new Error('Cannot merge empty array of aggregations')\n  }\n\n  if (aggregations.length === 1) {\n    const firstAggregation = aggregations[0]\n    if (!firstAggregation) {\n      throw new Error('First aggregation is undefined')\n    }\n    return firstAggregation\n  }\n\n  const timestamps = aggregations.map(agg => ({\n    start: new Date(agg.periodStart).getTime(),\n    end: new Date(agg.periodEnd).getTime(),\n  }))\n\n  const periodStart = new Date(Math.min(...timestamps.map(t => t.start))).toISOString()\n  const periodEnd = new Date(Math.max(...timestamps.map(t => t.end))).toISOString()\n\n  const totalEventCount = aggregations.reduce((sum, agg) => sum + agg.eventCount, 0)\n  const totalRepositoryCount = aggregations.reduce((sum, agg) => sum + agg.repositoryCount, 0)\n\n  // Weighted averages based on event count\n  const weightedCacheHitRate =\n    aggregations.reduce((sum, agg) => sum + agg.cacheHitRate * agg.eventCount, 0) / totalEventCount\n  const weightedAvgCacheDuration =\n    aggregations.reduce((sum, agg) => sum + agg.avgCacheDuration * agg.eventCount, 0) / totalEventCount\n  const weightedAvgDockerDuration =\n    aggregations.reduce((sum, agg) => sum + agg.avgDockerDuration * agg.eventCount, 0) / totalEventCount\n  const weightedAvgApiDuration =\n    aggregations.reduce((sum, agg) => sum + agg.avgApiDuration * agg.eventCount, 0) / totalEventCount\n  const weightedAvgActionDuration =\n    aggregations.reduce((sum, agg) => sum + agg.avgActionDuration * agg.eventCount, 0) / totalEventCount\n  const weightedActionSuccessRate =\n    aggregations.reduce((sum, agg) => sum + agg.actionSuccessRate * agg.eventCount, 0) / totalEventCount\n\n  // Merge failure counts\n  const mergedFailures: Record<FailureCategory, number> = {\n    permissions: 0,\n    authentication: 0,\n    'cache-corruption': 0,\n    'network-issues': 0,\n    'configuration-error': 0,\n    'docker-issues': 0,\n    'api-limits': 0,\n    timeout: 0,\n    unknown: 0,\n  }\n\n  for (const agg of aggregations) {\n    for (const [category, count] of Object.entries(agg.failuresByCategory)) {\n      mergedFailures[category as FailureCategory] += count\n    }\n  }\n\n  return {\n    periodStart,\n    periodEnd,\n    eventCount: totalEventCount,\n    repositoryCount: totalRepositoryCount,\n    cacheHitRate: weightedCacheHitRate,\n    avgCacheDuration: weightedAvgCacheDuration,\n    avgDockerDuration: weightedAvgDockerDuration,\n    avgApiDuration: weightedAvgApiDuration,\n    failuresByCategory: mergedFailures,\n    avgActionDuration: weightedAvgActionDuration,\n    actionSuccessRate: weightedActionSuccessRate,\n    schemaVersion: '1.0.0',\n  }\n}\n","/**\n * GitHub Actions Cache integration for analytics data storage with versioned keys.\n * Provides secure, efficient storage and retrieval of analytics data using cache infrastructure.\n */\n\nimport type {AggregatedAnalytics, AnalyticsConfig, AnalyticsEvent} from './models.js'\nimport {Buffer} from 'node:buffer'\nimport {env} from 'node:process'\n\nimport * as cache from '@actions/cache'\n\nimport {AnalyticsLogger, withTiming} from './logger.js'\n\n/**\n * Cache key structure for analytics data organization.\n */\nexport interface CacheKey {\n  /** Base prefix for all analytics cache keys */\n  readonly prefix: string\n  /** Repository identifier */\n  readonly repository: string\n  /** Data type (events, aggregated, config) */\n  readonly type: 'events' | 'aggregated' | 'config'\n  /** Version for schema compatibility */\n  readonly version: string\n  /** Optional timestamp for time-based partitioning */\n  readonly timestamp?: string\n}\n\n/**\n * Cache operation result with metadata.\n */\nexport interface CacheResult<T = unknown> {\n  /** Whether the operation was successful */\n  readonly success: boolean\n  /** Data retrieved/stored (if applicable) */\n  readonly data?: T\n  /** Cache key used for the operation */\n  readonly key: string\n  /** Operation duration in milliseconds */\n  readonly duration: number\n  /** Cache hit status (for restore operations) */\n  readonly hit?: boolean\n  /** Cache size in bytes */\n  readonly size?: number\n  /** Error message if operation failed */\n  readonly error?: string\n}\n\n/**\n * Configuration for cache operations.\n */\nexport interface CacheOperationConfig {\n  /** Maximum cache size in bytes */\n  readonly maxSize: number\n  /** Cache TTL in milliseconds */\n  readonly ttl: number\n  /** Whether to compress data before caching */\n  readonly compress: boolean\n  /** Compression algorithm to use */\n  readonly compressionAlgorithm: 'gzip' | 'brotli'\n  /** Maximum number of retry attempts */\n  readonly maxRetries: number\n  /** Retry delay in milliseconds */\n  readonly retryDelay: number\n}\n\n/**\n * Default cache operation configuration.\n */\nexport const DEFAULT_CACHE_CONFIG: CacheOperationConfig = {\n  maxSize: 10 * 1024 * 1024, // 10MB\n  ttl: 7 * 24 * 60 * 60 * 1000, // 7 days\n  compress: true,\n  compressionAlgorithm: 'gzip',\n  maxRetries: 3,\n  retryDelay: 1000,\n} as const\n\n/**\n * Analytics cache manager for GitHub Actions Cache integration.\n */\nexport class AnalyticsCache {\n  private readonly config: CacheOperationConfig\n  private readonly logger: AnalyticsLogger\n  private readonly analyticsConfig: AnalyticsConfig\n\n  constructor(analyticsConfig: AnalyticsConfig, config: Partial<CacheOperationConfig> = {}) {\n    this.analyticsConfig = analyticsConfig\n    this.config = {...DEFAULT_CACHE_CONFIG, ...config}\n    this.logger = AnalyticsLogger.fromAnalyticsConfig(analyticsConfig, 'cache')\n  }\n\n  /**\n   * Generate a cache key from components.\n   */\n  generateKey(keyComponents: CacheKey): string {\n    const parts = [keyComponents.prefix, keyComponents.repository, keyComponents.type, keyComponents.version]\n\n    if (typeof keyComponents.timestamp === 'string' && keyComponents.timestamp.length > 0) {\n      parts.push(keyComponents.timestamp)\n    }\n\n    return parts.join('-')\n  }\n\n  /**\n   * Parse a cache key back into components.\n   */\n  parseKey(key: string): CacheKey | null {\n    const parts = key.split('-')\n    if (parts.length < 4) {\n      return null\n    }\n\n    const [prefix, repository, type, version, ...timestampParts] = parts\n\n    if (\n      typeof prefix !== 'string' ||\n      prefix.length === 0 ||\n      typeof repository !== 'string' ||\n      repository.length === 0 ||\n      typeof type !== 'string' ||\n      type.length === 0 ||\n      typeof version !== 'string' ||\n      version.length === 0\n    ) {\n      return null\n    }\n\n    return {\n      prefix,\n      repository,\n      type: type as CacheKey['type'],\n      version,\n      timestamp: timestampParts.length > 0 ? timestampParts.join('-') : undefined,\n    }\n  }\n\n  /**\n   * Store analytics events in cache.\n   */\n  async storeEvents(\n    repository: string,\n    events: readonly AnalyticsEvent[],\n    timestamp?: string,\n  ): Promise<CacheResult<readonly AnalyticsEvent[]>> {\n    const keyComponents: CacheKey = {\n      prefix: this.analyticsConfig.cacheKeyPrefix,\n      repository,\n      type: 'events',\n      version: '1.0',\n      timestamp: timestamp ?? new Date().toISOString().split('T')[0], // YYYY-MM-DD\n    }\n\n    return this.storeData(keyComponents, events)\n  }\n\n  /**\n   * Retrieve analytics events from cache.\n   */\n  async retrieveEvents(repository: string, timestamp?: string): Promise<CacheResult<readonly AnalyticsEvent[]>> {\n    const keyComponents: CacheKey = {\n      prefix: this.analyticsConfig.cacheKeyPrefix,\n      repository,\n      type: 'events',\n      version: '1.0',\n      timestamp: timestamp ?? new Date().toISOString().split('T')[0], // YYYY-MM-DD\n    }\n\n    return this.retrieveData<readonly AnalyticsEvent[]>(keyComponents)\n  }\n\n  /**\n   * Store aggregated analytics data in cache.\n   */\n  async storeAggregated(\n    repository: string,\n    aggregated: AggregatedAnalytics,\n    timestamp?: string,\n  ): Promise<CacheResult<AggregatedAnalytics>> {\n    const keyComponents: CacheKey = {\n      prefix: this.analyticsConfig.cacheKeyPrefix,\n      repository,\n      type: 'aggregated',\n      version: '1.0',\n      timestamp: timestamp ?? new Date().toISOString().split('T')[0], // YYYY-MM-DD\n    }\n\n    return this.storeData(keyComponents, aggregated)\n  }\n\n  /**\n   * Retrieve aggregated analytics data from cache.\n   */\n  async retrieveAggregated(repository: string, timestamp?: string): Promise<CacheResult<AggregatedAnalytics>> {\n    const keyComponents: CacheKey = {\n      prefix: this.analyticsConfig.cacheKeyPrefix,\n      repository,\n      type: 'aggregated',\n      version: '1.0',\n      timestamp: timestamp ?? new Date().toISOString().split('T')[0], // YYYY-MM-DD\n    }\n\n    return this.retrieveData<AggregatedAnalytics>(keyComponents)\n  }\n\n  /**\n   * List all cache keys for a repository.\n   */\n  async listKeys(repository: string): Promise<string[]> {\n    // Note: GitHub Actions Cache doesn't provide a direct list API\n    // This is a placeholder for potential future implementation\n    // In practice, keys would need to be tracked separately\n    this.logger.warn('listKeys is not directly supported by GitHub Actions Cache API', {\n      repository,\n      feature: 'cache-listing',\n    })\n    return []\n  }\n\n  /**\n   * Clear all analytics cache data for a repository.\n   */\n  async clearRepository(repository: string): Promise<void> {\n    // Note: GitHub Actions Cache doesn't provide direct deletion API\n    // Cache entries expire automatically based on TTL and inactivity\n    this.logger.info('Cache data will expire automatically based on TTL', {\n      repository,\n      ttl: this.config.ttl,\n    })\n  }\n\n  /**\n   * Get cache usage statistics.\n   */\n  async getCacheStats(): Promise<{\n    totalSize: number\n    entryCount: number\n    oldestEntry?: string\n    newestEntry?: string\n  }> {\n    // Note: GitHub Actions Cache doesn't provide direct stats API\n    // This would need to be tracked separately\n    this.logger.warn('Cache statistics are not directly available from GitHub Actions Cache API')\n    return {\n      totalSize: 0,\n      entryCount: 0,\n    }\n  }\n\n  /**\n   * Generic method to store data in cache with error handling and retries.\n   */\n  private async storeData<T>(keyComponents: CacheKey, data: T): Promise<CacheResult<T>> {\n    const key = this.generateKey(keyComponents)\n\n    return withTiming(\n      `cache-store-${keyComponents.type}`,\n      async () => {\n        try {\n          // Serialize data to JSON\n          const jsonData = JSON.stringify(data)\n          const dataSize = Buffer.byteLength(jsonData, 'utf8')\n\n          // Check size limits\n          if (dataSize > this.config.maxSize) {\n            throw new Error(`Data size (${dataSize} bytes) exceeds maximum cache size (${this.config.maxSize} bytes)`)\n          }\n\n          // Write data to temporary file for caching\n          const {writeFile, mkdtemp, rm} = await import('node:fs/promises')\n          const pathModule = await import('node:path')\n          const {tmpdir} = await import('node:os')\n\n          const tempDir = await mkdtemp(pathModule.join(tmpdir(), 'analytics-cache-'))\n          const tempFile = pathModule.join(tempDir, 'data.json')\n\n          try {\n            await writeFile(tempFile, jsonData, 'utf8')\n\n            // Save to cache with retry logic\n            let lastError: Error | undefined\n            for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {\n              try {\n                const cacheId = await cache.saveCache([tempFile], key)\n                this.logger.info('Successfully stored data in cache', {\n                  key,\n                  cacheId,\n                  size: dataSize,\n                  attempt,\n                })\n\n                return {\n                  success: true,\n                  data,\n                  key,\n                  duration: 0, // Will be filled by withTiming\n                  size: dataSize,\n                }\n              } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error))\n                this.logger.warn(`Cache store attempt ${attempt} failed`, {\n                  key,\n                  attempt,\n                  maxRetries: this.config.maxRetries,\n                  error: lastError.message,\n                })\n\n                if (attempt < this.config.maxRetries) {\n                  await new Promise(resolve => {\n                    setTimeout(resolve, this.config.retryDelay * attempt)\n                  })\n                }\n              }\n            }\n\n            throw lastError ?? new Error('All cache store attempts failed')\n          } finally {\n            // Clean up temporary file\n            await rm(tempDir, {recursive: true, force: true})\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error)\n          this.logger.error('Failed to store data in cache', error instanceof Error ? error : undefined, {\n            key,\n            type: keyComponents.type,\n          })\n\n          return {\n            success: false,\n            key,\n            duration: 0, // Will be filled by withTiming\n            error: errorMessage,\n          }\n        }\n      },\n      this.logger,\n    ).then(({result, duration}) => ({...result, duration}))\n  }\n\n  /**\n   * Generic method to retrieve data from cache with error handling and retries.\n   */\n  private async retrieveData<T>(keyComponents: CacheKey): Promise<CacheResult<T>> {\n    const key = this.generateKey(keyComponents)\n\n    return withTiming(\n      `cache-retrieve-${keyComponents.type}`,\n      async () => {\n        try {\n          // Prepare temporary directory for cache restoration\n          const {mkdtemp, readFile, rm} = await import('node:fs/promises')\n          const pathModule = await import('node:path')\n          const {tmpdir} = await import('node:os')\n\n          const tempDir = await mkdtemp(pathModule.join(tmpdir(), 'analytics-cache-'))\n          const tempFile = pathModule.join(tempDir, 'data.json')\n\n          try {\n            // Restore from cache with retry logic\n            let lastError: Error | undefined\n            let cacheHit = false\n\n            for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {\n              try {\n                const cacheKey = await cache.restoreCache([tempFile], key)\n                if (typeof cacheKey === 'string' && cacheKey.length > 0) {\n                  cacheHit = true\n                  this.logger.info('Successfully restored data from cache', {\n                    key,\n                    cacheKey,\n                    attempt,\n                  })\n                  break\n                } else {\n                  this.logger.debug('Cache miss', {key, attempt})\n                  return {\n                    success: true,\n                    key,\n                    duration: 0, // Will be filled by withTiming\n                    hit: false,\n                  }\n                }\n              } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error))\n                this.logger.warn(`Cache restore attempt ${attempt} failed`, {\n                  key,\n                  attempt,\n                  maxRetries: this.config.maxRetries,\n                  error: lastError.message,\n                })\n\n                if (attempt < this.config.maxRetries) {\n                  await new Promise(resolve => {\n                    setTimeout(resolve, this.config.retryDelay * attempt)\n                  })\n                }\n              }\n            }\n\n            if (!cacheHit) {\n              throw lastError ?? new Error('All cache restore attempts failed')\n            }\n\n            // Read and parse data\n            const jsonData = await readFile(tempFile, 'utf8')\n            const data = JSON.parse(jsonData) as T\n            const dataSize = Buffer.byteLength(jsonData, 'utf8')\n\n            this.logger.info('Successfully parsed cached data', {\n              key,\n              size: dataSize,\n            })\n\n            return {\n              success: true,\n              data,\n              key,\n              duration: 0, // Will be filled by withTiming\n              hit: true,\n              size: dataSize,\n            }\n          } finally {\n            // Clean up temporary directory\n            await rm(tempDir, {recursive: true, force: true})\n          }\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error)\n          this.logger.error('Failed to retrieve data from cache', error instanceof Error ? error : undefined, {\n            key,\n            type: keyComponents.type,\n          })\n\n          return {\n            success: false,\n            key,\n            duration: 0, // Will be filled by withTiming\n            hit: false,\n            error: errorMessage,\n          }\n        }\n      },\n      this.logger,\n    ).then(({result, duration}) => ({...result, duration}))\n  }\n}\n\n/**\n * Create cache key components for analytics events.\n */\nexport function createEventsCacheKey(prefix: string, repository: string, timestamp?: string): CacheKey {\n  return {\n    prefix,\n    repository,\n    type: 'events',\n    version: '1.0',\n    timestamp: timestamp ?? new Date().toISOString().split('T')[0],\n  }\n}\n\n/**\n * Create cache key components for aggregated analytics data.\n */\nexport function createAggregatedCacheKey(prefix: string, repository: string, timestamp?: string): CacheKey {\n  return {\n    prefix,\n    repository,\n    type: 'aggregated',\n    version: '1.0',\n    timestamp: timestamp ?? new Date().toISOString().split('T')[0],\n  }\n}\n\n/**\n * Utility function to create repository identifier from GitHub context.\n */\nexport function getRepositoryIdentifier(): string {\n  const repository = env.GITHUB_REPOSITORY\n  if (typeof repository !== 'string' || repository.length === 0) {\n    throw new Error('GITHUB_REPOSITORY environment variable is not set')\n  }\n  return repository.replace('/', '-') // Convert owner/repo to owner-repo for cache key\n}\n\n/**\n * Utility function to check if cache operations are available.\n */\nexport function isCacheAvailable(): boolean {\n  try {\n    // Check if we're running in GitHub Actions environment\n    const cacheUrl = env.ACTIONS_CACHE_URL\n    const runtimeToken = env.ACTIONS_RUNTIME_TOKEN\n    return Boolean(\n      typeof cacheUrl === 'string' &&\n        cacheUrl.length > 0 &&\n        typeof runtimeToken === 'string' &&\n        runtimeToken.length > 0,\n    )\n  } catch {\n    return false\n  }\n}\n","/**\n * Configuration system for enabling/disabling analytics collection.\n * Supports environment variables and programmatic configuration.\n */\n\nimport type {LogLevel} from './logger.js'\nimport type {AnalyticsConfig} from './models.js'\nimport process from 'node:process'\n\nimport {DEFAULT_ANALYTICS_CONFIG} from './models.js'\n\n/**\n * Environment variable names for analytics configuration.\n */\nexport const ENV_VAR_NAMES = {\n  /** Whether analytics collection is enabled */\n  ENABLED: 'RENOVATE_ANALYTICS_ENABLED',\n  /** Log level for analytics operations */\n  LOG_LEVEL: 'RENOVATE_ANALYTICS_LOG_LEVEL',\n  /** Whether to collect cache metrics */\n  COLLECT_CACHE: 'RENOVATE_ANALYTICS_COLLECT_CACHE',\n  /** Whether to collect Docker metrics */\n  COLLECT_DOCKER: 'RENOVATE_ANALYTICS_COLLECT_DOCKER',\n  /** Whether to collect API metrics */\n  COLLECT_API: 'RENOVATE_ANALYTICS_COLLECT_API',\n  /** Whether to collect failure metrics */\n  COLLECT_FAILURES: 'RENOVATE_ANALYTICS_COLLECT_FAILURES',\n  /** Sample rate for metrics collection (0-1) */\n  SAMPLE_RATE: 'RENOVATE_ANALYTICS_SAMPLE_RATE',\n  /** Cache key prefix for analytics data storage */\n  CACHE_KEY_PREFIX: 'RENOVATE_ANALYTICS_CACHE_KEY_PREFIX',\n  /** Maximum size of analytics data to store (bytes) */\n  MAX_DATA_SIZE: 'RENOVATE_ANALYTICS_MAX_DATA_SIZE',\n  /** Data retention period in days */\n  RETENTION_DAYS: 'RENOVATE_ANALYTICS_RETENTION_DAYS',\n  /** Sensitive data patterns to sanitize (comma-separated) */\n  SANITIZE_PATTERNS: 'RENOVATE_ANALYTICS_SANITIZE_PATTERNS',\n} as const\n\n/**\n * Configuration validation errors.\n */\nexport class ConfigValidationError extends Error {\n  readonly field: string\n  readonly value: unknown\n\n  constructor(message: string, field: string, value: unknown) {\n    super(`Configuration validation error for ${field}: ${message}`)\n    this.name = 'ConfigValidationError'\n    this.field = field\n    this.value = value\n  }\n}\n\n/**\n * Parse a boolean value from environment variable.\n */\nfunction parseBoolean(value: string | undefined, defaultValue: boolean): boolean {\n  if (value === undefined) return defaultValue\n  const normalized = value.toLowerCase().trim()\n  if (normalized === 'true' || normalized === '1' || normalized === 'yes') return true\n  if (normalized === 'false' || normalized === '0' || normalized === 'no') return false\n  throw new ConfigValidationError(`Expected boolean value, got: ${value}`, 'boolean', value)\n}\n\n/**\n * Parse a number value from environment variable with validation.\n */\nfunction parseNumber(value: string | undefined, defaultValue: number, min?: number, max?: number): number {\n  if (value === undefined) return defaultValue\n  const parsed = Number.parseFloat(value.trim())\n  if (Number.isNaN(parsed)) {\n    throw new ConfigValidationError(`Expected number, got: ${value}`, 'number', value)\n  }\n  if (min !== undefined && parsed < min) {\n    throw new ConfigValidationError(`Value ${parsed} is below minimum ${min}`, 'number', value)\n  }\n  if (max !== undefined && parsed > max) {\n    throw new ConfigValidationError(`Value ${parsed} is above maximum ${max}`, 'number', value)\n  }\n  return parsed\n}\n\n/**\n * Parse log level from environment variable with validation.\n */\nfunction parseLogLevel(value: string | undefined, defaultValue: LogLevel): LogLevel {\n  if (value === undefined) return defaultValue\n  const normalized = value.toLowerCase().trim() as LogLevel\n  const validLevels: LogLevel[] = ['debug', 'info', 'warn', 'error']\n  if (!validLevels.includes(normalized)) {\n    throw new ConfigValidationError(`Expected one of: ${validLevels.join(', ')}, got: ${value}`, 'logLevel', value)\n  }\n  return normalized\n}\n\n/**\n * Parse comma-separated patterns from environment variable.\n */\nfunction parsePatterns(value: string | undefined, defaultValue: readonly string[]): readonly string[] {\n  if (value === undefined) return defaultValue\n  return value\n    .split(',')\n    .map(pattern => pattern.trim())\n    .filter(pattern => pattern.length > 0)\n}\n\n/**\n * Validate analytics configuration values.\n */\nfunction validateConfig(config: AnalyticsConfig): void {\n  // Validate sample rate\n  if (config.sampleRate < 0 || config.sampleRate > 1) {\n    throw new ConfigValidationError(\n      `Sample rate must be between 0 and 1, got: ${config.sampleRate}`,\n      'sampleRate',\n      config.sampleRate,\n    )\n  }\n\n  // Validate data size\n  if (config.maxDataSize <= 0) {\n    throw new ConfigValidationError(\n      `Max data size must be positive, got: ${config.maxDataSize}`,\n      'maxDataSize',\n      config.maxDataSize,\n    )\n  }\n\n  // Validate retention days\n  if (config.retentionDays <= 0) {\n    throw new ConfigValidationError(\n      `Retention days must be positive, got: ${config.retentionDays}`,\n      'retentionDays',\n      config.retentionDays,\n    )\n  }\n\n  // Validate cache key prefix\n  if (!config.cacheKeyPrefix || config.cacheKeyPrefix.trim().length === 0) {\n    throw new ConfigValidationError('Cache key prefix cannot be empty', 'cacheKeyPrefix', config.cacheKeyPrefix)\n  }\n\n  // Validate sanitize patterns\n  if (config.sanitizePatterns.length === 0) {\n    throw new ConfigValidationError(\n      'At least one sanitize pattern must be provided',\n      'sanitizePatterns',\n      config.sanitizePatterns,\n    )\n  }\n}\n\n/**\n * Load analytics configuration from environment variables.\n */\nexport function loadConfigFromEnvironment(): AnalyticsConfig {\n  try {\n    const config: AnalyticsConfig = {\n      enabled: parseBoolean(process.env[ENV_VAR_NAMES.ENABLED], DEFAULT_ANALYTICS_CONFIG.enabled),\n      logLevel: parseLogLevel(process.env[ENV_VAR_NAMES.LOG_LEVEL], DEFAULT_ANALYTICS_CONFIG.logLevel),\n      collectCache: parseBoolean(process.env[ENV_VAR_NAMES.COLLECT_CACHE], DEFAULT_ANALYTICS_CONFIG.collectCache),\n      collectDocker: parseBoolean(process.env[ENV_VAR_NAMES.COLLECT_DOCKER], DEFAULT_ANALYTICS_CONFIG.collectDocker),\n      collectApi: parseBoolean(process.env[ENV_VAR_NAMES.COLLECT_API], DEFAULT_ANALYTICS_CONFIG.collectApi),\n      collectFailures: parseBoolean(process.env[ENV_VAR_NAMES.COLLECT_FAILURES], DEFAULT_ANALYTICS_CONFIG.collectFailures),\n      sampleRate: parseNumber(process.env[ENV_VAR_NAMES.SAMPLE_RATE], DEFAULT_ANALYTICS_CONFIG.sampleRate, 0, 1),\n      cacheKeyPrefix: process.env[ENV_VAR_NAMES.CACHE_KEY_PREFIX] ?? DEFAULT_ANALYTICS_CONFIG.cacheKeyPrefix,\n      maxDataSize: parseNumber(process.env[ENV_VAR_NAMES.MAX_DATA_SIZE], DEFAULT_ANALYTICS_CONFIG.maxDataSize, 1),\n      retentionDays: parseNumber(process.env[ENV_VAR_NAMES.RETENTION_DAYS], DEFAULT_ANALYTICS_CONFIG.retentionDays, 1),\n      sanitizePatterns: parsePatterns(process.env[ENV_VAR_NAMES.SANITIZE_PATTERNS], DEFAULT_ANALYTICS_CONFIG.sanitizePatterns),\n    }\n\n    validateConfig(config)\n    return config\n  } catch (error) {\n    if (error instanceof ConfigValidationError) {\n      throw error\n    }\n    throw new ConfigValidationError(\n      `Failed to parse configuration: ${error instanceof Error ? error.message : String(error)}`,\n      'general',\n      error,\n    )\n  }\n}\n\n/**\n * Create analytics configuration with overrides.\n */\nexport function createConfig(overrides: Partial<AnalyticsConfig> = {}): AnalyticsConfig {\n  const config: AnalyticsConfig = {\n    ...DEFAULT_ANALYTICS_CONFIG,\n    ...overrides,\n  }\n\n  validateConfig(config)\n  return config\n}\n\n/**\n * Check if analytics collection is enabled based on configuration.\n */\nexport function isAnalyticsEnabled(config: AnalyticsConfig): boolean {\n  return config.enabled\n}\n\n/**\n * Check if specific metric collection is enabled.\n */\nexport function isMetricCollectionEnabled(\n  config: AnalyticsConfig,\n  metricType: 'cache' | 'docker' | 'api' | 'failures',\n): boolean {\n  if (!config.enabled) return false\n\n  switch (metricType) {\n    case 'cache':\n      return config.collectCache\n    case 'docker':\n      return config.collectDocker\n    case 'api':\n      return config.collectApi\n    case 'failures':\n      return config.collectFailures\n    default:\n      return false\n  }\n}\n\n/**\n * Check if analytics should be collected based on sample rate.\n */\nexport function shouldCollectSample(config: AnalyticsConfig): boolean {\n  if (!config.enabled) return false\n  if (config.sampleRate >= 1) return true\n  if (config.sampleRate <= 0) return false\n  return Math.random() < config.sampleRate\n}\n\n/**\n * Get configuration summary for logging.\n */\nexport function getConfigSummary(config: AnalyticsConfig): Record<string, unknown> {\n  return {\n    enabled: config.enabled,\n    logLevel: config.logLevel,\n    collectCache: config.collectCache,\n    collectDocker: config.collectDocker,\n    collectApi: config.collectApi,\n    collectFailures: config.collectFailures,\n    sampleRate: config.sampleRate,\n    cacheKeyPrefix: config.cacheKeyPrefix,\n    maxDataSize: config.maxDataSize,\n    retentionDays: config.retentionDays,\n    sanitizePatternsCount: config.sanitizePatterns.length,\n  }\n}\n\n/**\n * Default analytics configuration instance loaded from environment.\n */\nlet defaultConfig: AnalyticsConfig | undefined\n\n/**\n * Get the default analytics configuration (loaded once from environment).\n */\nexport function getDefaultConfig(): AnalyticsConfig {\n  if (!defaultConfig) {\n    defaultConfig = loadConfigFromEnvironment()\n  }\n  return defaultConfig\n}\n\n/**\n * Reset the default configuration cache (useful for testing).\n */\nexport function resetDefaultConfig(): void {\n  defaultConfig = undefined\n}\n","/**\n * Analytics data models and TypeScript interfaces for Renovate action metrics.\n * Supports cache, Docker, API, and failure tracking across repositories.\n */\n\n/**\n * Timestamp in ISO 8601 format for consistent temporal data representation.\n */\nexport type Timestamp = string\n\n/**\n * Repository identifier for analytics context.\n */\nexport interface RepositoryInfo {\n  /** Repository owner/organization name */\n  readonly owner: string\n  /** Repository name */\n  readonly repo: string\n  /** Full repository name in owner/repo format */\n  readonly fullName: string\n  /** GitHub repository ID */\n  readonly id: number\n  /** Repository size in bytes (approximation) */\n  readonly size?: number\n  /** Primary programming language */\n  readonly language?: string\n  /** Repository visibility (public/private) */\n  readonly visibility: 'public' | 'private'\n}\n\n/**\n * GitHub Actions workflow run context for analytics correlation.\n */\nexport interface WorkflowContext {\n  /** GitHub Actions run ID */\n  readonly runId: string\n  /** GitHub Actions run number */\n  readonly runNumber: number\n  /** Workflow name */\n  readonly workflowName: string\n  /** Triggering event (push, pull_request, schedule, etc.) */\n  readonly eventName: string\n  /** Git reference (branch/tag) */\n  readonly ref: string\n  /** Git SHA */\n  readonly sha: string\n  /** Actor who triggered the workflow */\n  readonly actor: string\n}\n\n/**\n * Cache operation metrics for performance analysis.\n */\nexport interface CacheMetrics {\n  /** Cache operation type */\n  readonly operation: 'restore' | 'save' | 'prepare' | 'finalize'\n  /** Cache key used for the operation */\n  readonly key: string\n  /** Cache key version/pattern for migration tracking */\n  readonly version: string\n  /** Operation start timestamp */\n  readonly startTime: Timestamp\n  /** Operation end timestamp */\n  readonly endTime: Timestamp\n  /** Operation duration in milliseconds */\n  readonly duration: number\n  /** Whether the operation was successful */\n  readonly success: boolean\n  /** Cache hit/miss status (null for save operations) */\n  readonly hit?: boolean\n  /** Cache size in bytes */\n  readonly size?: number\n  /** Error message if operation failed */\n  readonly error?: string\n  /** Additional operation-specific metadata */\n  readonly metadata?: Record<string, unknown>\n}\n\n/**\n * Docker operation metrics for container performance analysis.\n */\nexport interface DockerMetrics {\n  /** Docker operation type */\n  readonly operation: 'pull' | 'run' | 'exec' | 'tool-install'\n  /** Docker image name and tag */\n  readonly image?: string\n  /** Container ID if applicable */\n  readonly containerId?: string\n  /** Tool being installed (for tool-install operations) */\n  readonly tool?: string\n  /** Tool version being installed */\n  readonly toolVersion?: string\n  /** Operation start timestamp */\n  readonly startTime: Timestamp\n  /** Operation end timestamp */\n  readonly endTime: Timestamp\n  /** Operation duration in milliseconds */\n  readonly duration: number\n  /** Whether the operation was successful */\n  readonly success: boolean\n  /** Exit code for container operations */\n  readonly exitCode?: number\n  /** Error message if operation failed */\n  readonly error?: string\n  /** Additional operation-specific metadata */\n  readonly metadata?: Record<string, unknown>\n}\n\n/**\n * GitHub API usage metrics for rate limiting and performance analysis.\n */\nexport interface ApiMetrics {\n  /** API endpoint or operation type */\n  readonly endpoint: string\n  /** HTTP method used */\n  readonly method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n  /** Request start timestamp */\n  readonly startTime: Timestamp\n  /** Request end timestamp */\n  readonly endTime: Timestamp\n  /** Request duration in milliseconds */\n  readonly duration: number\n  /** HTTP response status code */\n  readonly statusCode: number\n  /** Whether the request was successful (2xx status) */\n  readonly success: boolean\n  /** Rate limit remaining after request */\n  readonly rateLimitRemaining?: number\n  /** Rate limit reset timestamp */\n  readonly rateLimitReset?: Timestamp\n  /** Whether this was a secondary rate limit */\n  readonly secondaryRateLimit?: boolean\n  /** Authentication method used */\n  readonly authMethod: 'github-app' | 'pat' | 'none'\n  /** Error message if request failed */\n  readonly error?: string\n  /** Response size in bytes */\n  readonly responseSize?: number\n}\n\n/**\n * Failure scenario categories matching troubleshooting guide.\n */\nexport type FailureCategory =\n  | 'permissions'\n  | 'authentication'\n  | 'cache-corruption'\n  | 'network-issues'\n  | 'configuration-error'\n  | 'docker-issues'\n  | 'api-limits'\n  | 'timeout'\n  | 'unknown'\n\n/**\n * Failure metrics for error analysis and troubleshooting.\n */\nexport interface FailureMetrics {\n  /** Failure category for classification */\n  readonly category: FailureCategory\n  /** Specific failure type within category */\n  readonly type: string\n  /** Failure occurrence timestamp */\n  readonly timestamp: Timestamp\n  /** Error message (sanitized) */\n  readonly message: string\n  /** Stack trace (sanitized, optional) */\n  readonly stackTrace?: string\n  /** Related component that failed */\n  readonly component: 'cache' | 'docker' | 'api' | 'config' | 'action' | 'renovate'\n  /** Whether the failure was recoverable */\n  readonly recoverable: boolean\n  /** Number of retry attempts made */\n  readonly retryAttempts?: number\n  /** Additional failure context */\n  readonly context?: Record<string, unknown>\n}\n\n/**\n * Renovate action performance metrics summary.\n */\nexport interface ActionMetrics {\n  /** Action execution start timestamp */\n  readonly startTime: Timestamp\n  /** Action execution end timestamp */\n  readonly endTime: Timestamp\n  /** Total action duration in milliseconds */\n  readonly duration: number\n  /** Whether the action completed successfully */\n  readonly success: boolean\n  /** Renovate version used */\n  readonly renovateVersion: string\n  /** Action version/commit SHA */\n  readonly actionVersion: string\n  /** Number of repositories processed */\n  readonly repositoriesProcessed?: number\n  /** Number of pull requests created */\n  readonly pullRequestsCreated?: number\n  /** Number of dependencies updated */\n  readonly dependenciesUpdated?: number\n  /** Exit code of the action */\n  readonly exitCode: number\n  /** Final error message if action failed */\n  readonly error?: string\n}\n\n/**\n * Complete analytics event containing all metric types and context.\n */\nexport interface AnalyticsEvent {\n  /** Unique event identifier */\n  readonly id: string\n  /** Event timestamp */\n  readonly timestamp: Timestamp\n  /** Repository context */\n  readonly repository: RepositoryInfo\n  /** Workflow context */\n  readonly workflow: WorkflowContext\n  /** Cache metrics collected during execution */\n  readonly cache: readonly CacheMetrics[]\n  /** Docker metrics collected during execution */\n  readonly docker: readonly DockerMetrics[]\n  /** API metrics collected during execution */\n  readonly api: readonly ApiMetrics[]\n  /** Failure metrics if any failures occurred */\n  readonly failures: readonly FailureMetrics[]\n  /** Overall action performance metrics */\n  readonly action: ActionMetrics\n  /** Event schema version for compatibility */\n  readonly schemaVersion: string\n}\n\n/**\n * Aggregated analytics data for multi-repository reporting.\n */\nexport interface AggregatedAnalytics {\n  /** Aggregation period start timestamp */\n  readonly periodStart: Timestamp\n  /** Aggregation period end timestamp */\n  readonly periodEnd: Timestamp\n  /** Number of events aggregated */\n  readonly eventCount: number\n  /** Number of unique repositories */\n  readonly repositoryCount: number\n  /** Cache hit rate percentage (0-100) */\n  readonly cacheHitRate: number\n  /** Average cache operation duration in milliseconds */\n  readonly avgCacheDuration: number\n  /** Average Docker operation duration in milliseconds */\n  readonly avgDockerDuration: number\n  /** Average API request duration in milliseconds */\n  readonly avgApiDuration: number\n  /** Total number of failures by category */\n  readonly failuresByCategory: Record<FailureCategory, number>\n  /** Average action execution duration in milliseconds */\n  readonly avgActionDuration: number\n  /** Action success rate percentage (0-100) */\n  readonly actionSuccessRate: number\n  /** Aggregation schema version */\n  readonly schemaVersion: string\n}\n\n/**\n * Analytics configuration for controlling data collection.\n */\nexport interface AnalyticsConfig {\n  /** Whether analytics collection is enabled */\n  readonly enabled: boolean\n  /** Log level for analytics operations */\n  readonly logLevel: 'debug' | 'info' | 'warn' | 'error'\n  /** Whether to collect cache metrics */\n  readonly collectCache: boolean\n  /** Whether to collect Docker metrics */\n  readonly collectDocker: boolean\n  /** Whether to collect API metrics */\n  readonly collectApi: boolean\n  /** Whether to collect failure metrics */\n  readonly collectFailures: boolean\n  /** Sample rate for metrics collection (0-1) */\n  readonly sampleRate: number\n  /** Cache key prefix for analytics data storage */\n  readonly cacheKeyPrefix: string\n  /** Maximum size of analytics data to store (bytes) */\n  readonly maxDataSize: number\n  /** Data retention period in days */\n  readonly retentionDays: number\n  /** Sensitive data patterns to sanitize */\n  readonly sanitizePatterns: readonly string[]\n}\n\n/**\n * Current schema version for analytics data structures.\n */\nexport const ANALYTICS_SCHEMA_VERSION = '1.0.0'\n\n/**\n * Default analytics configuration values.\n */\nexport const DEFAULT_ANALYTICS_CONFIG: AnalyticsConfig = {\n  enabled: false,\n  logLevel: 'info',\n  collectCache: true,\n  collectDocker: true,\n  collectApi: true,\n  collectFailures: true,\n  sampleRate: 1,\n  cacheKeyPrefix: 'renovate-analytics',\n  maxDataSize: 10 * 1024 * 1024, // 10MB\n  retentionDays: 7,\n  sanitizePatterns: ['token', 'password', 'secret', 'key', 'auth', 'credential', 'bearer', 'private'],\n} as const\n","/**\n * Data sanitization functions to prevent secrets leakage in analytics data.\n * Provides comprehensive detection and redaction of sensitive information.\n */\n\nimport type {AnalyticsConfig} from './models.js'\nimport {createHash} from 'node:crypto'\n\nimport {AnalyticsLogger} from './logger.js'\n\n/**\n * Types of sensitive data patterns to detect and sanitize.\n */\nexport type SensitiveDataType =\n  | 'token'\n  | 'password'\n  | 'secret'\n  | 'key'\n  | 'credential'\n  | 'bearer'\n  | 'cookie'\n  | 'session'\n  | 'private'\n  | 'email'\n  | 'url'\n  | 'ip'\n  | 'uuid'\n\n/**\n * Sanitization strategy for different types of sensitive data.\n */\nexport type SanitizationStrategy = 'redact' | 'hash' | 'partial' | 'remove'\n\n/**\n * Configuration for data sanitization operations.\n */\nexport interface SanitizationConfig {\n  /** Default strategy to use for unknown sensitive data */\n  readonly defaultStrategy: SanitizationStrategy\n  /** Strategies for specific data types */\n  readonly strategies: Record<SensitiveDataType, SanitizationStrategy>\n  /** Custom regex patterns to detect sensitive data */\n  readonly customPatterns: readonly SensitivePattern[]\n  /** Maximum length for partial masking */\n  readonly partialMaskLength: number\n  /** Character to use for masking */\n  readonly maskCharacter: string\n  /** Whether to preserve data structure in sanitized output */\n  readonly preserveStructure: boolean\n  /** Salt for hashing (should be unique per installation) */\n  readonly hashSalt: string\n}\n\n/**\n * Custom pattern for detecting sensitive data.\n */\nexport interface SensitivePattern {\n  /** Name of the pattern for logging/debugging */\n  readonly name: string\n  /** Regular expression to match sensitive data */\n  readonly pattern: RegExp\n  /** Data type category */\n  readonly type: SensitiveDataType\n  /** Sanitization strategy for this pattern */\n  readonly strategy: SanitizationStrategy\n  /** Whether this pattern should be case-sensitive */\n  readonly caseSensitive: boolean\n}\n\n/**\n * Result of sanitization operation with metadata.\n */\nexport interface SanitizationResult {\n  /** Sanitized data */\n  readonly data: unknown\n  /** Number of values that were sanitized */\n  readonly sanitizedCount: number\n  /** Types of sensitive data found */\n  readonly foundTypes: readonly SensitiveDataType[]\n  /** Whether any data was modified */\n  readonly wasModified: boolean\n  /** Warnings or notes about sanitization */\n  readonly warnings: readonly string[]\n}\n\n/**\n * Default sanitization configuration.\n */\nexport const DEFAULT_SANITIZATION_CONFIG: SanitizationConfig = {\n  defaultStrategy: 'redact',\n  strategies: {\n    token: 'redact',\n    password: 'redact',\n    secret: 'redact',\n    key: 'redact',\n    credential: 'redact',\n    bearer: 'redact',\n    cookie: 'redact',\n    session: 'redact',\n    private: 'redact',\n    email: 'partial',\n    url: 'partial',\n    ip: 'hash',\n    uuid: 'hash',\n  },\n  customPatterns: [],\n  partialMaskLength: 4,\n  maskCharacter: '*',\n  preserveStructure: true,\n  hashSalt: 'renovate-analytics-salt',\n} as const\n\n/**\n * Pre-defined patterns for common sensitive data types.\n */\nexport const BUILTIN_SENSITIVE_PATTERNS: readonly SensitivePattern[] = [\n  // GitHub tokens\n  {\n    name: 'github-token',\n    pattern: /\\b(gh[ops]_\\w{36,255})\\b/g,\n    type: 'token',\n    strategy: 'redact',\n    caseSensitive: true,\n  },\n  // Generic API keys\n  {\n    name: 'api-key',\n    pattern: /\\b(api[_-]?key|access[_-]?token|secret[_-]?key)\\s*[:=]\\s*['\"]?([\\w+/=]{20,})['\"]?/gi,\n    type: 'key',\n    strategy: 'redact',\n    caseSensitive: false,\n  },\n  // Bearer tokens\n  {\n    name: 'bearer-token',\n    pattern: /\\bbearer\\s+([\\w+/=]{20,})\\b/gi,\n    type: 'bearer',\n    strategy: 'redact',\n    caseSensitive: false,\n  },\n  // Basic auth\n  {\n    name: 'basic-auth',\n    pattern: /\\bbasic\\s+([\\w+/=]{4,})\\b/gi,\n    type: 'credential',\n    strategy: 'redact',\n    caseSensitive: false,\n  },\n  // JWT tokens\n  {\n    name: 'jwt-token',\n    pattern: /\\beyJ[\\w+/=]+\\.[\\w+/=]+\\.[\\w+/=]*\\b/g,\n    type: 'token',\n    strategy: 'redact',\n    caseSensitive: true,\n  },\n  // URLs with credentials\n  {\n    name: 'url-with-credentials',\n    pattern: /(https?:\\/\\/)[^:@\\s]+:[^@\\s]+@([^/\\s]+)/gi,\n    type: 'url',\n    strategy: 'partial',\n    caseSensitive: false,\n  },\n  // Email addresses\n  {\n    name: 'email-address',\n    pattern: /\\b[\\w.%+-]+@[\\w.-]+\\.[a-z]{2,}\\b/gi,\n    type: 'email',\n    strategy: 'partial',\n    caseSensitive: false,\n  },\n  // IP addresses\n  {\n    name: 'ip-address',\n    pattern: /\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b/g,\n    type: 'ip',\n    strategy: 'hash',\n    caseSensitive: true,\n  },\n  // UUIDs\n  {\n    name: 'uuid',\n    pattern: /\\b[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}\\b/gi,\n    type: 'uuid',\n    strategy: 'hash',\n    caseSensitive: false,\n  },\n  // Private keys\n  {\n    name: 'private-key',\n    pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----[\\s\\S]*?-----END [A-Z ]+PRIVATE KEY-----/gi,\n    type: 'private',\n    strategy: 'redact',\n    caseSensitive: false,\n  },\n] as const\n\n/**\n * Data sanitizer for preventing secrets leakage in analytics.\n */\nexport class DataSanitizer {\n  private readonly config: SanitizationConfig\n  private readonly logger: AnalyticsLogger\n  private readonly allPatterns: readonly SensitivePattern[]\n\n  constructor(config: Partial<SanitizationConfig> = {}, logger?: AnalyticsLogger) {\n    this.config = {...DEFAULT_SANITIZATION_CONFIG, ...config}\n    this.logger = logger ?? new AnalyticsLogger({component: 'sanitizer'})\n    this.allPatterns = [...BUILTIN_SENSITIVE_PATTERNS, ...this.config.customPatterns]\n  }\n\n  /**\n   * Create sanitizer from analytics configuration.\n   */\n  static fromAnalyticsConfig(analyticsConfig: AnalyticsConfig, logger?: AnalyticsLogger): DataSanitizer {\n    const config: Partial<SanitizationConfig> = {\n      customPatterns: analyticsConfig.sanitizePatterns.map(pattern => ({\n        name: `custom-${pattern}`,\n        pattern: new RegExp(pattern, 'gi'),\n        type: 'secret' as const,\n        strategy: 'redact' as const,\n        caseSensitive: false,\n      })),\n    }\n\n    return new DataSanitizer(config, logger)\n  }\n\n  /**\n   * Sanitize any data structure, removing or masking sensitive information.\n   */\n  sanitize(data: unknown): SanitizationResult {\n    const startTime = Date.now()\n    let sanitizedCount = 0\n    const foundTypes = new Set<SensitiveDataType>()\n    const warnings: string[] = []\n\n    this.logger.operationStart('sanitize-data', {\n      dataType: typeof data,\n      preserveStructure: this.config.preserveStructure,\n    })\n\n    try {\n      const sanitizedData = this.sanitizeValue(data, foundTypes, count => {\n        sanitizedCount += count\n      })\n\n      const wasModified = sanitizedCount > 0\n\n      if (wasModified) {\n        this.logger.info('Data sanitization completed', {\n          sanitizedCount,\n          foundTypes: Array.from(foundTypes),\n          preserveStructure: this.config.preserveStructure,\n        })\n      }\n\n      this.logger.operationEnd('sanitize-data', startTime, true, {\n        sanitizedCount,\n        foundTypesCount: foundTypes.size,\n      })\n\n      return {\n        data: sanitizedData,\n        sanitizedCount,\n        foundTypes: Array.from(foundTypes),\n        wasModified,\n        warnings,\n      }\n    } catch (error) {\n      this.logger.operationEnd('sanitize-data', startTime, false)\n      this.logger.error('Data sanitization failed', error instanceof Error ? error : new Error(String(error)))\n      throw error\n    }\n  }\n\n  /**\n   * Sanitize a string value using pattern matching.\n   */\n  sanitizeString(input: string): {sanitized: string; types: readonly SensitiveDataType[]} {\n    let sanitized = input\n    const foundTypes = new Set<SensitiveDataType>()\n\n    for (const pattern of this.allPatterns) {\n      const regex = new RegExp(pattern.pattern.source, pattern.pattern.flags)\n      const matches = [...sanitized.matchAll(regex)]\n\n      if (matches.length > 0) {\n        foundTypes.add(pattern.type)\n\n        for (const match of matches) {\n          const sensitiveValue = match[0]\n          const sanitizedValue = this.applySanitizationStrategy(sensitiveValue, pattern.strategy)\n          sanitized = sanitized.replace(sensitiveValue, sanitizedValue)\n        }\n      }\n    }\n\n    // Check for common sensitive key patterns in JSON-like strings\n    const keyPatterns = this.config.strategies\n    for (const [keyType, strategy] of Object.entries(keyPatterns)) {\n      const keyPattern = new RegExp(`[\"']?${keyType}[\"']?\\\\s*[:=]\\\\s*[\"']?([^\"',\\\\s}]+)[\"']?`, 'gi')\n      const matches = [...sanitized.matchAll(keyPattern)]\n\n      if (matches.length > 0) {\n        foundTypes.add(keyType as SensitiveDataType)\n\n        for (const match of matches) {\n          const fullMatch = match[0]\n          const sensitiveValue = match[1]\n          if (typeof sensitiveValue === 'string' && sensitiveValue.length > 0) {\n            const sanitizedValue = this.applySanitizationStrategy(sensitiveValue, strategy)\n            const sanitizedFullMatch = fullMatch.replace(sensitiveValue, sanitizedValue)\n            sanitized = sanitized.replace(fullMatch, sanitizedFullMatch)\n          }\n        }\n      }\n    }\n\n    return {\n      sanitized,\n      types: Array.from(foundTypes),\n    }\n  }\n\n  /**\n   * Recursively sanitize any value type.\n   */\n  private sanitizeValue(\n    value: unknown,\n    foundTypes: Set<SensitiveDataType>,\n    countCallback: (count: number) => void,\n  ): unknown {\n    if (value === null || value === undefined) {\n      return value\n    }\n\n    if (typeof value === 'string') {\n      const {sanitized, types} = this.sanitizeString(value)\n      types.forEach(type => foundTypes.add(type))\n      if (sanitized !== value) {\n        countCallback(1)\n      }\n      return sanitized\n    }\n\n    if (typeof value === 'number' || typeof value === 'boolean') {\n      return value\n    }\n\n    if (Array.isArray(value)) {\n      if (!this.config.preserveStructure) {\n        return '[Array]'\n      }\n      return value.map(item => this.sanitizeValue(item, foundTypes, countCallback))\n    }\n\n    if (typeof value === 'object') {\n      if (!this.config.preserveStructure) {\n        return '[Object]'\n      }\n\n      const sanitizedObj: Record<string, unknown> = {}\n      for (const [key, val] of Object.entries(value as Record<string, unknown>)) {\n        // Check if the key itself is sensitive\n        const {sanitized: sanitizedKey} = this.sanitizeString(key)\n        if (sanitizedKey !== key) {\n          countCallback(1)\n        }\n\n        // Sanitize the value\n        const sanitizedValue = this.sanitizeValue(val, foundTypes, countCallback)\n        sanitizedObj[sanitizedKey] = sanitizedValue\n      }\n      return sanitizedObj\n    }\n\n    // For other types, convert to string and sanitize\n    const stringValue = String(value)\n    const {sanitized} = this.sanitizeString(stringValue)\n    if (sanitized !== stringValue) {\n      countCallback(1)\n    }\n    return sanitized\n  }\n\n  /**\n   * Apply sanitization strategy to a sensitive value.\n   */\n  private applySanitizationStrategy(value: string, strategy: SanitizationStrategy): string {\n    switch (strategy) {\n      case 'redact':\n        return '[REDACTED]'\n\n      case 'remove':\n        return ''\n\n      case 'partial': {\n        if (value.length <= this.config.partialMaskLength * 2) {\n          return this.config.maskCharacter.repeat(value.length)\n        }\n        const keepLength = this.config.partialMaskLength\n        const start = value.slice(0, keepLength)\n        const end = value.slice(-keepLength)\n        const middleLength = value.length - keepLength * 2\n        const middle = this.config.maskCharacter.repeat(middleLength)\n        return `${start}${middle}${end}`\n      }\n\n      case 'hash': {\n        // Simple hash for demonstration - in production, use a proper crypto library\n        const hash = createHash('sha256')\n        hash.update(value + this.config.hashSalt)\n        return `[HASH:${hash.digest('hex').slice(0, 8)}]`\n      }\n\n      default:\n        this.logger.warn('Unknown sanitization strategy, using redact', {strategy})\n        return '[REDACTED]'\n    }\n  }\n\n  /**\n   * Test if a string contains sensitive data without modifying it.\n   */\n  containsSensitiveData(input: string): {hasSensitiveData: boolean; types: readonly SensitiveDataType[]} {\n    const foundTypes = new Set<SensitiveDataType>()\n\n    for (const pattern of this.allPatterns) {\n      const regex = new RegExp(pattern.pattern.source, pattern.pattern.flags)\n      if (regex.test(input)) {\n        foundTypes.add(pattern.type)\n      }\n    }\n\n    return {\n      hasSensitiveData: foundTypes.size > 0,\n      types: Array.from(foundTypes),\n    }\n  }\n\n  /**\n   * Get sanitization statistics for monitoring.\n   */\n  getStats(): {\n    patternsCount: number\n    strategiesCount: number\n    builtinPatternsCount: number\n    customPatternsCount: number\n  } {\n    return {\n      patternsCount: this.allPatterns.length,\n      strategiesCount: Object.keys(this.config.strategies).length,\n      builtinPatternsCount: BUILTIN_SENSITIVE_PATTERNS.length,\n      customPatternsCount: this.config.customPatterns.length,\n    }\n  }\n\n  /**\n   * Add a custom pattern for detecting sensitive data.\n   */\n  addCustomPattern(pattern: SensitivePattern): void {\n    // Note: This modifies the instance but doesn't affect the original config\n    // In a production system, you might want to make this immutable\n    ;(this.allPatterns as SensitivePattern[]).push(pattern)\n    this.logger.info('Added custom sanitization pattern', {\n      name: pattern.name,\n      type: pattern.type,\n      strategy: pattern.strategy,\n    })\n  }\n}\n\n/**\n * Quick utility function to sanitize a string with default configuration.\n */\nexport function sanitizeString(input: string): string {\n  const sanitizer = new DataSanitizer()\n  const {sanitized} = sanitizer.sanitizeString(input)\n  return sanitized\n}\n\n/**\n * Quick utility function to sanitize any data with default configuration.\n */\nexport function sanitizeData(data: unknown): unknown {\n  const sanitizer = new DataSanitizer()\n  const result = sanitizer.sanitize(data)\n  return result.data\n}\n\n/**\n * Utility function to check if data contains sensitive information.\n */\nexport function hasSensitiveData(data: unknown): boolean {\n  if (typeof data === 'string') {\n    const sanitizer = new DataSanitizer()\n    return sanitizer.containsSensitiveData(data).hasSensitiveData\n  }\n\n  // For non-string data, convert to JSON and check\n  try {\n    const jsonString = JSON.stringify(data)\n    const sanitizer = new DataSanitizer()\n    return sanitizer.containsSensitiveData(jsonString).hasSensitiveData\n  } catch {\n    return false\n  }\n}\n","/**\n * Analytics data schema validation and error handling.\n * Provides runtime validation for all analytics data structures.\n */\n\nimport type {LogLevel} from './logger.js'\n\n/**\n * Schema validation errors with detailed context.\n */\nexport class SchemaValidationError extends Error {\n  readonly field: string\n  readonly value: unknown\n  readonly expectedType: string\n  readonly actualType: string\n\n  constructor(message: string, field: string, value: unknown, expectedType: string) {\n    const actualType = value === null ? 'null' : typeof value\n    super(`Schema validation error for ${field}: ${message}. Expected ${expectedType}, got ${actualType}`)\n    this.name = 'SchemaValidationError'\n    this.field = field\n    this.value = value\n    this.expectedType = expectedType\n    this.actualType = actualType\n  }\n}\n\n/**\n * Validation result with success flag and errors.\n */\nexport interface ValidationResult {\n  readonly success: boolean\n  readonly errors: readonly SchemaValidationError[]\n  readonly warnings: readonly string[]\n}\n\n/**\n * Create successful validation result.\n */\nfunction createValidationSuccess(warnings: string[] = []): ValidationResult {\n  return {\n    success: true,\n    errors: [],\n    warnings,\n  }\n}\n\n/**\n * Create failed validation result.\n */\nfunction createValidationFailure(errors: SchemaValidationError[], warnings: string[] = []): ValidationResult {\n  return {\n    success: false,\n    errors,\n    warnings,\n  }\n}\n\n/**\n * Utility functions for type checking and validation.\n */\nconst validators = {\n  isString: (value: unknown): value is string => typeof value === 'string',\n  isNumber: (value: unknown): value is number => typeof value === 'number' && !Number.isNaN(value),\n  isBoolean: (value: unknown): value is boolean => typeof value === 'boolean',\n  isArray: (value: unknown): value is unknown[] => Array.isArray(value),\n  isObject: (value: unknown): value is Record<string, unknown> =>\n    value !== null && typeof value === 'object' && !Array.isArray(value),\n  isTimestamp: (value: unknown): value is string => {\n    if (typeof value !== 'string') return false\n    const date = new Date(value)\n    return !Number.isNaN(date.getTime()) && value.includes('T')\n  },\n  isLogLevel: (value: unknown): value is LogLevel => {\n    return typeof value === 'string' && ['debug', 'info', 'warn', 'error'].includes(value)\n  },\n  isPositiveNumber: (value: unknown): value is number => {\n    return typeof value === 'number' && !Number.isNaN(value) && value > 0\n  },\n  isNonNegativeNumber: (value: unknown): value is number => {\n    return typeof value === 'number' && !Number.isNaN(value) && value >= 0\n  },\n  isValidSampleRate: (value: unknown): value is number => {\n    return typeof value === 'number' && !Number.isNaN(value) && value >= 0 && value <= 1\n  },\n}\n\n/**\n * Validate repository information structure.\n */\nexport function validateRepositoryInfo(data: unknown): ValidationResult {\n  const errors: SchemaValidationError[] = []\n  const warnings: string[] = []\n\n  if (!validators.isObject(data)) {\n    return createValidationFailure([\n      new SchemaValidationError('Repository info must be an object', 'root', data, 'object'),\n    ])\n  }\n\n  // Required fields\n  if (!validators.isString(data.owner)) {\n    errors.push(new SchemaValidationError('Owner must be a string', 'owner', data.owner, 'string'))\n  }\n  if (!validators.isString(data.repo)) {\n    errors.push(new SchemaValidationError('Repo must be a string', 'repo', data.repo, 'string'))\n  }\n  if (!validators.isString(data.fullName)) {\n    errors.push(new SchemaValidationError('Full name must be a string', 'fullName', data.fullName, 'string'))\n  }\n  if (!validators.isNumber(data.id)) {\n    errors.push(new SchemaValidationError('ID must be a number', 'id', data.id, 'number'))\n  }\n  if (!validators.isString(data.visibility) || !['public', 'private'].includes(data.visibility)) {\n    errors.push(\n      new SchemaValidationError('Visibility must be \"public\" or \"private\"', 'visibility', data.visibility, 'string'),\n    )\n  }\n\n  // Optional fields\n  if (data.size !== undefined && !validators.isNonNegativeNumber(data.size)) {\n    warnings.push('Repository size should be a non-negative number')\n  }\n  if (data.language !== undefined && !validators.isString(data.language)) {\n    warnings.push('Repository language should be a string')\n  }\n\n  return errors.length > 0 ? createValidationFailure(errors, warnings) : createValidationSuccess(warnings)\n}\n\n/**\n * Validate cache metrics structure.\n */\nexport function validateCacheMetrics(data: unknown): ValidationResult {\n  const errors: SchemaValidationError[] = []\n  const warnings: string[] = []\n\n  if (!validators.isObject(data)) {\n    return createValidationFailure([\n      new SchemaValidationError('Cache metrics must be an object', 'root', data, 'object'),\n    ])\n  }\n\n  // Validate operation type\n  if (!validators.isString(data.operation) || !['restore', 'save', 'prepare', 'finalize'].includes(data.operation)) {\n    errors.push(\n      new SchemaValidationError(\n        'Operation must be one of: restore, save, prepare, finalize',\n        'operation',\n        data.operation,\n        'string',\n      ),\n    )\n  }\n\n  // Required fields\n  if (!validators.isString(data.key)) {\n    errors.push(new SchemaValidationError('Key must be a string', 'key', data.key, 'string'))\n  }\n  if (!validators.isString(data.version)) {\n    errors.push(new SchemaValidationError('Version must be a string', 'version', data.version, 'string'))\n  }\n  if (!validators.isTimestamp(data.startTime)) {\n    errors.push(\n      new SchemaValidationError('Start time must be a valid ISO timestamp', 'startTime', data.startTime, 'string'),\n    )\n  }\n  if (!validators.isTimestamp(data.endTime)) {\n    errors.push(new SchemaValidationError('End time must be a valid ISO timestamp', 'endTime', data.endTime, 'string'))\n  }\n  if (!validators.isNonNegativeNumber(data.duration)) {\n    errors.push(\n      new SchemaValidationError('Duration must be a non-negative number', 'duration', data.duration, 'number'),\n    )\n  }\n  if (!validators.isBoolean(data.success)) {\n    errors.push(new SchemaValidationError('Success must be a boolean', 'success', data.success, 'boolean'))\n  }\n\n  // Optional fields\n  if (data.hit !== undefined && !validators.isBoolean(data.hit)) {\n    warnings.push('Hit should be a boolean')\n  }\n  if (data.size !== undefined && !validators.isNonNegativeNumber(data.size)) {\n    warnings.push('Size should be a non-negative number')\n  }\n  if (data.error !== undefined && !validators.isString(data.error)) {\n    warnings.push('Error should be a string')\n  }\n\n  return errors.length > 0 ? createValidationFailure(errors, warnings) : createValidationSuccess(warnings)\n}\n\n/**\n * Validate analytics configuration structure.\n */\nexport function validateAnalyticsConfig(data: unknown): ValidationResult {\n  const errors: SchemaValidationError[] = []\n\n  if (!validators.isObject(data)) {\n    return createValidationFailure([\n      new SchemaValidationError('Analytics config must be an object', 'root', data, 'object'),\n    ])\n  }\n\n  // Required boolean fields\n  const booleanFields = ['enabled', 'collectCache', 'collectDocker', 'collectApi', 'collectFailures']\n  for (const field of booleanFields) {\n    if (!validators.isBoolean(data[field])) {\n      errors.push(new SchemaValidationError(`${field} must be a boolean`, field, data[field], 'boolean'))\n    }\n  }\n\n  // Log level validation\n  if (!validators.isLogLevel(data.logLevel)) {\n    errors.push(\n      new SchemaValidationError('Log level must be debug, info, warn, or error', 'logLevel', data.logLevel, 'LogLevel'),\n    )\n  }\n\n  // Sample rate validation\n  if (!validators.isValidSampleRate(data.sampleRate)) {\n    errors.push(\n      new SchemaValidationError('Sample rate must be between 0 and 1', 'sampleRate', data.sampleRate, 'number'),\n    )\n  }\n\n  // String fields\n  if (!validators.isString(data.cacheKeyPrefix)) {\n    errors.push(\n      new SchemaValidationError('Cache key prefix must be a string', 'cacheKeyPrefix', data.cacheKeyPrefix, 'string'),\n    )\n  }\n\n  // Positive number fields\n  if (!validators.isPositiveNumber(data.maxDataSize)) {\n    errors.push(\n      new SchemaValidationError('Max data size must be a positive number', 'maxDataSize', data.maxDataSize, 'number'),\n    )\n  }\n  if (!validators.isPositiveNumber(data.retentionDays)) {\n    errors.push(\n      new SchemaValidationError(\n        'Retention days must be a positive number',\n        'retentionDays',\n        data.retentionDays,\n        'number',\n      ),\n    )\n  }\n\n  // Sanitize patterns validation\n  if (validators.isArray(data.sanitizePatterns)) {\n    for (const [index, pattern] of data.sanitizePatterns.entries()) {\n      if (!validators.isString(pattern)) {\n        errors.push(\n          new SchemaValidationError(\n            `Sanitize pattern at index ${index} must be a string`,\n            `sanitizePatterns[${index}]`,\n            pattern,\n            'string',\n          ),\n        )\n      }\n    }\n  } else {\n    errors.push(\n      new SchemaValidationError(\n        'Sanitize patterns must be an array',\n        'sanitizePatterns',\n        data.sanitizePatterns,\n        'array',\n      ),\n    )\n  }\n\n  return errors.length > 0 ? createValidationFailure(errors) : createValidationSuccess()\n}\n\n/**\n * Validate any analytics data structure with type detection.\n */\nexport function validateAnalyticsData(data: unknown, expectedType?: string): ValidationResult {\n  if (expectedType !== undefined && expectedType !== null && expectedType !== '') {\n    switch (expectedType) {\n      case 'RepositoryInfo':\n        return validateRepositoryInfo(data)\n      case 'CacheMetrics':\n        return validateCacheMetrics(data)\n      case 'AnalyticsConfig':\n        return validateAnalyticsConfig(data)\n      default:\n        return createValidationFailure([\n          new SchemaValidationError(`Unknown validation type: ${expectedType}`, 'type', expectedType, 'known type'),\n        ])\n    }\n  }\n\n  // Try to auto-detect the type based on structure\n  if (!validators.isObject(data)) {\n    return createValidationFailure([\n      new SchemaValidationError('Data must be an object for auto-validation', 'root', data, 'object'),\n    ])\n  }\n\n  // Check for config structure\n  if ('enabled' in data && 'logLevel' in data && 'sampleRate' in data) {\n    return validateAnalyticsConfig(data)\n  }\n\n  // Check for cache metrics\n  if ('operation' in data && 'key' in data && 'duration' in data) {\n    return validateCacheMetrics(data)\n  }\n\n  // Check for repository info\n  if ('owner' in data && 'repo' in data && 'fullName' in data) {\n    return validateRepositoryInfo(data)\n  }\n\n  return createValidationFailure([\n    new SchemaValidationError('Unable to detect data type for validation', 'type', data, 'known analytics type'),\n  ])\n}\n\n/**\n * Throw validation errors if validation fails.\n */\nexport function assertValidAnalyticsData(data: unknown, expectedType?: string): void {\n  const result = validateAnalyticsData(data, expectedType)\n  if (!result.success) {\n    const errorMessages = result.errors.map(err => err.message).join('; ')\n    const defaultType = 'valid analytics data'\n    const typeDescription =\n      expectedType !== undefined && expectedType !== null && expectedType !== '' ? expectedType : defaultType\n    throw new SchemaValidationError(`Validation failed: ${errorMessages}`, 'validation', data, typeDescription)\n  }\n}\n"],"mappings":"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","names":["error","error","env","error","env","error","error","sanitized"]}